
#include <iostream>//
#include <vector>//
#include <math.h>//power ^
#include <tuple> //tuple duh
#include <sstream> //tokens
#include <algorithm> //
#include <iterator>//
#include <string>//strings
#include <stdlib.h>//
#include <fstream> //ofstream
#include <utility>

//c++

using namespace std;

double long Dist(double long x, double long y, double long a, double long b) //Distance between two points or the edge length, could also use this for rem()
{
	double long val;
	val = sqrt(pow((x - a), 2.0) + pow((y - b), 2));
	return val;
}

vector<vector<tuple<int,double long>> > Weights(vector<tuple<int, double long, double long>> H, vector<vector<double long>> G)
{
	vector<vector<tuple<int, double long>> > Results;

	int O;//accessing the node
	int ListSize; //for loop
	int i; //counter

	double long x;//coordinates
	double long y;
	double long a;
	double long b;
	for (int i = 0; i < G.size(); i++) //while not at end of adjacenty list
	{
		x = get<1>(H[i]);
		y = get<2>(H[i]);
		vector<tuple<int, double long>> Temp; //empty vector
		for (int M = 1; M < G[i].size(); M++)//goes through list
		{
			double long W;
			O = G[i][M];
			O--;//since indexing is 0 to n-1 and node 1 is at index 0
			a = get<1>(H[O]);
			b = get<2>(H[O]);
			O++;
			W = Dist(a, b, x, y);
			tuple<int, double long> weight(O, W);
			Temp.push_back(weight);
		}
		Results.push_back(Temp);

	}
	return Results;
}
/*
vector<string> A_Star(vector<tuple<string, int, int>> G, vector< vector< int> > H, int S, int T)
{
	// G is list of nodes
	// H is adjaceny list
	// S source node
	// T target node

	//create 
}

tuple<double,int> Disjkra(int s, int t, vector< vector<double long> > A, vector<vector<tuple<int, double long>> > W)
{
	// A is the adjancy list
	// W weights
	//s soutce
	//t destination
	

	// create a list of the distances and set source to 0 and the rest to inf
	vector<double> Distances(1000); 
	fill(Distances.begin(), Distances.end(), INFINITY);
	int temp = s;
	temp--;
	Distances[temp] = 0;

	// a tuple vector for piorty queue
	vector<tuple<double,int>> H;
	for (int i= 1; i <=1000 ; i++)
	{
		if (i = s)
		{
			tuple<double, int> inside(0, i);
			H.push_back(inside);
		}
		else
		{
			tuple<double, int> inside(INFINITY, i);
			H.push_back(inside);
		}
	}
	while (!H.empty()) //while queue not empty
	{
		sort(H.begin(), H.end()); //sort so min is first
		tuple<double, int> U = H[0]; //get min
		H.erase(H.begin()); //delete min
		int node = get<1>(U); //what node it is
		int Vloc; 
		Vloc=node--; //vector are 0 to (n-1) so change the index
		if (node == t) // if at destination
		{
			tuple<double, int> leng(node, 5); //store nodes visited, length of path
			return leng;
		}
		for (size_t i = 0; i < A[Vloc].size(); i++) //for all edges
		{
			int temp;
			int Adj;
			Adj=get<0>(W[Vloc][size_t]) //what node edge we are using
			temp=get<0>(U)+get<1>(W[Vloc][size_t]); //temp is the path length
			if(temp<Distances[Adj]) // if path is shorter
			{
				//update H
				//update Distance
				
			}
		}
	}


	for(){}// loop that finds the number of nodes in Distance that is not inf. that is number of nodes visited
	//returns how many nodes visited + shortest path
	
	tuple<double, int> REs(34, 23);//store nodes visited, length of path
	return REs;
}
*/
tuple<vector<tuple<int, double long, double long>>, vector< vector<double long> >> readfile()
{
	ifstream myfile("graph1000.txt");
	vector< vector<double long> > Adjlist;
	vector<tuple<int, double long, double long>> NODES;
	string temp;
	string line;
	string moo;
	double long Result;
	double long Result2;
	double long Result3;
	int space;
	space = 0;
	while (getline(myfile, line))
	{
		if (space == 1)
		{
			replace(line.begin(), line.end(), ':', ' ');  //replace : with ' '
			replace(line.begin(), line.end(), ',', ' ');  //replace , with ' '
			istringstream iss(line);
			vector<string> tokens;
			copy(istream_iterator<string>(iss),
				istream_iterator<string>(),
				back_inserter(tokens));

			int Adjsize;
			Adjsize = tokens.size();
			vector<double long> Adjtemp;
			for (int i = 0; i < Adjsize; i++)
			{
				istringstream convert(tokens[i]);
				convert >> Result;
				Adjtemp.push_back(Result);

			}
			Adjlist.push_back(Adjtemp);
		}
		if (line.empty())
		{
			space = 1;
		}


		if (space == 0) {
			replace(line.begin(), line.end(), ':', ' ');
			replace(line.begin(), line.end(), ',', ' ');
			istringstream iss(line);
			vector<string> tokens;
			copy(istream_iterator<string>(iss),
				istream_iterator<string>(),
				back_inserter(tokens));
			istringstream convert3(tokens[0]);
			convert3 >> Result3;
			istringstream convert(tokens[1]);
			convert >> Result;
			istringstream convert2(tokens[2]);
			convert2 >> Result2;
			tuple<double, double long, double long> temp(Result3, Result, Result2);
			NODES.push_back(temp);
		}


	}
	tuple<vector<tuple<int, double long, double long>>, vector< vector<double long> >> Re(NODES, Adjlist);
	return Re;
}


int main() 
{
	tuple<vector<tuple<int, double long, double long>>, vector< vector<double long> >> temp;
	temp = readfile();
	vector<tuple<int, double long, double long>> Nodes (get<0>(temp));
	vector< vector<double long> > AdjancyList (get<1>(temp));
	vector<vector<tuple<int, double long>> > W = Weights(Nodes, AdjancyList);
	//tuple<double long, int> Result = Disjkra(Nodes,AdjancyList,W);

	/* //reads to output file
	ofstream myfile;
	myfile.open("output.txt");
	for (int i = 0; i < W.size(); i++)
	{
		for (int j = 0; j< W[i].size(); j++)
		{
			myfile << get<0>(W[i][j]);
			myfile << " ";
		}
		myfile << endl;
	}
	myfile.close();
	*/
	return 0;
}